[![travis](https://api.travis-ci.org/JervenBolleman/sjh.svg?branch=master)](https://travis-ci.org/JervenBolleman/sjh)
# What is SJH

A proof of concept for generating HTML using java directly, hopefully no uglier than necesarry. While making it difficult to generate invalid HTML by leveraging the typesystem. 

#Why
Generating HTML for Java projects has always been done by non Java templates. e.g. JSPX or ThymeLeaf. These templates would have some programming support as well as accessing values from Java objects using the Java bean syntax.

However, these types of templates are dynamic runtime validated. This does not match nicely with the rest of the Java code which is statically typed. Here we try to see how far java8 can be stretched to generate readable code for generating HTML.

The idea is that it can fit in nicely with JAX-RS&JSR-371 as a good method for generating HTML views.

#But WHY ???

Are you insane, don't you know the greatness that is JSON and React and Angular or .... . Yes, I know of them. But in the day job project I work on: the backend code is 500,000 lines of Java, written and maintained over a 10 year period. The HTML is generated by 15,000 lines of jspx and tagx. As well some 3,200 lines of Java that generate HTML using a rather hacky extension to tag libs. The site is mostly readonly and has no complicated crud cycles.

We can't afford to throw away the backend Java. We need to maintain the frontend HTML in some manner or other. We have a datamodel that is very complicated and changes drastically over time as we need to keep up with the ever changing knowledge in biology. While at the same time having only a few developers that need to do maintainance and new feature development. Also there is no split between frontend and backend as all of us need to be able to work on all parts. There is also not just one place wher a model is used in the html views. Models have differrent views associcated with them and that makes it difficul to find all the places where a method/property is called.

Making more of the frontend depend on JSON and JS for rendering will make or SEO difficult. Makes the render parts for HTML complicated, while our other responses such as RDF, JSON, XML, GFF, FASTA, CSV, Excel and will have a completly separate rendering pipeline from the HTML one. For this reasons throwing more Java at the problem could be the right thing for us.

#Status

This is a proof of concept code base only. Will be worked on when I feel like it only.

#Main idea

Assume JAX-RS, 
```java

@Path("hello")
public class Hello {
        @GET
        public Response hello() {

                HTML html = html(head(title("hello")),
                                 body(main(h1("hello"))));
                return Response.status(Response.OK)
                                .entity(html().build();
        }
}

```

```java
@Path("users")
public class Users {
        @GET
        public Response user(@QueryParam("id") long userid) {

                User user = findUserEtc(userid);
                HTML html = html(head(title("hello")),
                                 body(main(new UserGreeting(user))));
                return Response.status(Response.OK)
                                .entity(html().build();

        private static class UserGreeting 
                extends H1 {
                private UserGreeting(User user) {
                        super("hello, dear ", user.getPrefferedName());
                }
        }
}
```


Which means if you decide to refactor the getPrefferedName() into getNickName(), your standard refactoring tools will be able to change it. Unlike when you are using JSPX or JSF.

```java
//First make the head of the page
Head head = head(title("test"));

//Then we map a list of user names to li elements using streams.
Stream<LI> map = users
    .stream()
    .map(u -> li(u));
OL orderedListOfUser = ol(map);

//Then we add a body tag with as child elements the ordered list of user names
Body body = body(orderedListOfUser);

//Make the whole page by having a root element html with the head and body child elements
HTML html = html(head, body);
```

This code shows it is easy to make elements on demand


#Leveraging the Java type system.

The java type system is not the best type system arround, but it can be used to make it hard to generate invalid html5 code.
For example you are not supposed to have a div inside a p element. This won't compile.

```java
p(div());
```

You will get a message like "The method ```p()``` in the Type elements is not applicable for the arguments ```div()```". 
There are invalid cases that you can still create, mostly nested varieties that are not valid. Mostly with what is called transparent content in html5.
Here the type of the child element depends on the parent element. This can be ensured statically but then we can't have the nice static constructor method anymore.



